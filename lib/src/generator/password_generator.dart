import '../config/password_generator_config.dart';
import '../feedback/ipassword_feedback_provider.dart';
import '../feedback/password_feedback_builder.dart';
import '../model/character_set_profile.dart';
import '../model/password_feedback.dart';
import '../model/password_generation_exception.dart';
import '../model/password_strength.dart';
import '../normalizer/ipassword_normalizer.dart';
import '../normalizer/password_normalizer.dart';
import '../strategy/ipassword_generation_strategy.dart';
import '../strategy/random_password_strategy.dart';
import '../strength_estimator/ipassword_strength_estimator.dart';
import '../strength_estimator/password_strength_estimator.dart';
import '../validator/config_aware_password_validator.dart';
import '../validator/iconfig_aware_password_validator.dart';
import '../validator/ipassword_validator.dart';
import 'ipassword_generator.dart';

/// A concrete implementation of [IPasswordGenerator] for generating secure passwords.
///
/// This class uses a modular, strategy-based approach to generate passwords.
/// It can be configured with different validation, strength estimation, and
/// generation strategies to provide a flexible and extensible password
/// generation solution.
class PasswordGenerator implements IPasswordGenerator {
  /// Creates a [PasswordGenerator] with optional custom strategies.
  ///
  /// The [validator], [strengthEstimator], and [generationStrategy] parameters
  /// allow for the injection of custom implementations. If any of these are
  /// not provided, default implementations will be used.
  PasswordGenerator({
    IPasswordValidator? validator,
    IPasswordStrengthEstimator? strengthEstimator,
    IPasswordGenerationStrategy? generationStrategy,
    IPasswordFeedbackProvider? feedbackProvider,
    IPasswordNormalizer? normalizer,
  }) : _validator = validator ?? ConfigAwarePasswordValidator(),
       _strengthEstimator = strengthEstimator ?? PasswordStrengthEstimator(),
       _generationStrategy = generationStrategy ?? RandomPasswordStrategy(),
       _feedbackProvider = feedbackProvider ?? PasswordFeedbackBuilder(),
       _normalizer = normalizer ?? DefaultPasswordNormalizer();

  final IPasswordValidator _validator;
  final IPasswordStrengthEstimator _strengthEstimator;
  final IPasswordGenerationStrategy _generationStrategy;
  final IPasswordFeedbackProvider _feedbackProvider;
  final IPasswordNormalizer _normalizer;
  PasswordGeneratorConfig? _config;
  String? _lastGeneratedPassword;

  /// Returns the last password generated by this instance.
  ///
  /// If no password has been generated yet, this will be `null`.
  String? get lastPassword => _lastGeneratedPassword;

  /// Updates the password generation configuration.
  ///
  /// The provided [config] will be used for subsequent password generations.
  void updateConfig(PasswordGeneratorConfig config) {
    _config = config;
  }

  @override
  String refreshPassword() {
    final config = _resolveConfig();
    final maxAttempts = config.maxGenerationAttempts;
    if (maxAttempts <= 0) {
      throw ArgumentError('maxGenerationAttempts must be greater than 0');
    }

    for (var attempt = 0; attempt < maxAttempts; attempt++) {
      final password = generatePassword();
      final normalized = _normalizer.normalize(password);
      if (_validator is IConfigAwarePasswordValidator) {
        if ((_validator).isStrongPasswordWithConfig(normalized, config)) {
          return password;
        }
      } else if (_validator.isStrongPassword(normalized)) {
        return password;
      }
    }

    throw PasswordGenerationException.maxAttemptsExceeded(
      maxAttempts: maxAttempts,
    );
  }

  @override
  String generatePassword({
    int? length,
    bool? useUpperCase,
    bool? useLowerCase,
    bool? useNumbers,
    bool? useSpecialChars,
    bool? excludeAmbiguousChars,
  }) {
    final settings = _resolveConfig(
      length: length,
      useUpperCase: useUpperCase,
      useLowerCase: useLowerCase,
      useNumbers: useNumbers,
      useSpecialChars: useSpecialChars,
      excludeAmbiguousChars: excludeAmbiguousChars,
    );

    final password = _generationStrategy.generate(settings);
    _lastGeneratedPassword = password;
    return password;
  }

  /// Estimates the strength of a given [password].
  ///
  /// Returns a [PasswordStrength] enum value indicating the estimated strength.
  PasswordStrength estimateStrength(String password) {
    return _strengthEstimator.estimatePasswordStrength(
      _normalizer.normalize(password),
    );
  }

  @override
  PasswordFeedback estimateFeedback(String password) {
    final strength = estimateStrength(password);
    return _feedbackProvider.build(strength);
  }

  PasswordGeneratorConfig _resolveConfig({
    int? length,
    bool? useUpperCase,
    bool? useLowerCase,
    bool? useNumbers,
    bool? useSpecialChars,
    bool? excludeAmbiguousChars,
  }) {
    return PasswordGeneratorConfig(
      length: length ?? _config?.length ?? 12,
      useUpperCase: useUpperCase ?? _config?.useUpperCase ?? true,
      useLowerCase: useLowerCase ?? _config?.useLowerCase ?? true,
      useNumbers: useNumbers ?? _config?.useNumbers ?? true,
      useSpecialChars: useSpecialChars ?? _config?.useSpecialChars ?? true,
      excludeAmbiguousChars:
          excludeAmbiguousChars ?? _config?.excludeAmbiguousChars ?? false,
      characterSetProfile:
          _config?.characterSetProfile ?? CharacterSetProfile.defaultProfile,
      maxGenerationAttempts:
          _config?.maxGenerationAttempts ??
          PasswordGeneratorConfig.defaultMaxGenerationAttempts,
      policy: _config?.policy,
      extra: _config?.extra ?? const {},
    );
  }
}
